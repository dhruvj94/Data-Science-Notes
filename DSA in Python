# 🧠 DSA Notes in Python (with Comments & Explanations)

---

## 📦 1. **Arrays / Lists**

**🔎 Use Case**: Store and access data in contiguous memory; ideal for index-based access.

```python
# Create and access elements in a list
arr = [10, 20, 30]
print(arr[1])  # Access element at index 1 → Output: 20

# Append an item at the end of the list
arr.append(40)

# Remove a specific value
arr.remove(20)

# Iterate through the list
for item in arr:
    print(item)
```

---

## 📋 2. **Stacks**

**🔎 Use Case**: Undo functionality, syntax parsing, backtracking (LIFO - Last In, First Out).

```python
stack = []

# Push elements onto the stack
stack.append(1)
stack.append(2)

# Pop the top element
print(stack.pop())  # Output: 2

# Peek at the top without removing
print(stack[-1])    # Output: 1
```

---

## 📄 3. **Queues**

**🔎 Use Case**: Task scheduling, buffering, BFS in graph traversal (FIFO - First In, First Out).

```python
from collections import deque

queue = deque()

# Enqueue elements
queue.append(1)
queue.append(2)

# Dequeue the first element added
print(queue.popleft())  # Output: 1
```

---

## 🔁 4. **Linked List**

**🔎 Use Case**: Efficient insertion/deletion at any position; useful when array resizing is expensive.

```python
class Node:
    def __init__(self, data):
        self.data = data  # Store the data
        self.next = None  # Pointer to next node

class LinkedList:
    def __init__(self):
        self.head = None  # Start with an empty list

    def append(self, data):
        # Add node at the end
        if not self.head:
            self.head = Node(data)
            return
        curr = self.head
        while curr.next:
            curr = curr.next
        curr.next = Node(data)

    def display(self):
        # Display all nodes
        curr = self.head
        while curr:
            print(curr.data, end=" -> ")
            curr = curr.next
        print("None")

ll = LinkedList()
ll.append(10)
ll.append(20)
ll.display()
```

---

## 🌲 5. **Binary Tree (Traversal)**

**🔎 Use Case**: Hierarchical data like file systems, decision trees, expression parsing.

```python
class TreeNode:
    def __init__(self, val):
        self.left = None
        self.right = None
        self.val = val

# Recursive Inorder Traversal (Left -> Root -> Right)
def inorder(root):
    if root:
        inorder(root.left)
        print(root.val)
        inorder(root.right)

# Build tree and traverse
root = TreeNode(1)
root.left = TreeNode(2)
root.right = TreeNode(3)
inorder(root)
```

---

## 🎯 6. **Searching Algorithms**

**🔎 Use Case**: To find elements efficiently in a dataset.

### ✅ Linear Search (O(n))

```python
def linear_search(arr, target):
    for i in range(len(arr)):
        if arr[i] == target:
            return i  # Return index of found item
    return -1  # Not found
```

### ✅ Binary Search (O(log n), only for sorted arrays)

```python
def binary_search(arr, target):
    low, high = 0, len(arr) - 1
    while low <= high:
        mid = (low + high) // 2
        if arr[mid] == target:
            return mid
        elif arr[mid] < target:
            low = mid + 1
        else:
            high = mid - 1
    return -1
```

---

## 📊 7. **Sorting Algorithms**

**🔎 Use Case**: Sorting is a foundational operation for searching, organizing, and visualization.

### ✅ Bubble Sort

```python
def bubble_sort(arr):
    n = len(arr)
    for i in range(n):
        for j in range(n - 1 - i):  # Avoid already sorted parts
            if arr[j] > arr[j + 1]:
                arr[j], arr[j + 1] = arr[j + 1], arr[j]  # Swap
```

### ✅ Quick Sort (Efficient divide-and-conquer sort)

```python
def quick_sort(arr):
    if len(arr) <= 1:
        return arr
    pivot = arr[0]  # Choose first element as pivot
    left = [x for x in arr[1:] if x < pivot]   # Smaller values
    right = [x for x in arr[1:] if x >= pivot] # Greater or equal
    return quick_sort(left) + [pivot] + quick_sort(right)
```

---

## 🔢 8. **Hash Table (Dictionary in Python)**

**🔎 Use Case**: Fast lookup and insert operations (average O(1) time).

```python
# Create a hash table
hash_map = {}

# Insert key-value pairs
hash_map["name"] = "Alice"
hash_map["age"] = 25

# Retrieve a value
print(hash_map.get("name"))  # Output: Alice
```

---

## 📉 9. **Graphs (BFS & DFS)**

**🔎 Use Case**: Represent relationships/networks (like social graphs, maps, etc.)

### ✅ Graph Representation

```python
graph = {
    'A': ['B', 'C'],
    'B': ['D'],
    'C': ['E'],
    'D': [],
    'E': ['F'],
    'F': []
}
```

### ✅ Breadth-First Search (BFS)

```python
from collections import deque

def bfs(graph, start):
    visited = set()
    queue = deque([start])
    
    while queue:
        node = queue.popleft()  # Process current
        if node not in visited:
            print(node)
            visited.add(node)
            queue.extend(graph[node])  # Add neighbors
```

### ✅ Depth-First Search (DFS)

```python
def dfs(graph, start, visited=None):
    if visited is None:
        visited = set()
    visited.add(start)
    print(start)
    for neighbor in graph[start]:
        if neighbor not in visited:
            dfs(graph, neighbor, visited)
```

---
